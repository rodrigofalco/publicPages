---
interface Props {
  diagram: string;
  loadingText?: string;
  hintText?: string;
}

const {
  diagram,
  loadingText = 'Loading diagram...',
  hintText = 'ðŸ’¡ Use mouse wheel to zoom, drag to pan'
} = Astro.props;
---

<div id="diagram-container">
    <div class="loading" id="loading">{loadingText}</div>
    <div class="mermaid" set:html={diagram} />
    <div class="hint">{hintText}</div>
</div>

<style>
    #diagram-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        overflow: hidden;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 8px;
        min-height: 600px;
        width: 100%;
        box-sizing: border-box;
    }

    .mermaid {
        text-align: center;
        width: 100%;
        height: 100%;
        max-width: 100%;
        overflow: hidden;
    }

    .mermaid :global(svg) {
        width: 100%;
        height: 100%;
    }

    .loading {
        text-align: center;
        padding: 40px;
        color: #666;
    }

    .hint {
        text-align: center;
        margin-top: 10px;
        color: #666;
        font-size: 0.85em;
    }

    @media (max-width: 820px) {
        #diagram-container {
            min-height: 400px;
        }
    }
</style>

<script>
    import mermaid from 'mermaid';

    mermaid.initialize({
        startOnLoad: true,
        theme: 'default',
        flowchart: {
            useMaxWidth: true,
            htmlLabels: true,
            curve: 'basis'
        },
        securityLevel: 'loose'
    });

    window.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
            const loading = document.getElementById('loading');
            if (loading) loading.style.display = 'none';
            initZoomAndPan();
        }, 1000);
    });

    function initZoomAndPan() {
        const svg = document.querySelector('.mermaid svg');
        if (!svg) return;

        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX: number, startY: number;

        svg.style.cursor = 'grab';

        // Zoom with mouse wheel
        svg.addEventListener('wheel', (e) => {
            e.preventDefault();

            const rect = svg.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldX = (mouseX - translateX) / scale;
            const worldY = (mouseY - translateY) / scale;

            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(scale * delta, 5));

            translateX = mouseX - worldX * newScale;
            translateY = mouseY - worldY * newScale;
            scale = newScale;

            updateTransform();
        });

        // Pan with mouse drag
        svg.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX - translateX;
            startY = e.clientY - translateY;
            svg.style.cursor = 'grabbing';
        });

        svg.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            translateX = e.clientX - startX;
            translateY = e.clientY - startY;
            updateTransform();
        });

        svg.addEventListener('mouseup', () => {
            isDragging = false;
            svg.style.cursor = 'grab';
        });

        svg.addEventListener('mouseleave', () => {
            isDragging = false;
            svg.style.cursor = 'grab';
        });

        // Touch support
        let touchStartX: number, touchStartY: number;
        svg.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX - translateX;
                touchStartY = e.touches[0].clientY - translateY;
            }
        });

        svg.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                translateX = e.touches[0].clientX - touchStartX;
                translateY = e.touches[0].clientY - touchStartY;
                updateTransform();
            }
        });

        function updateTransform() {
            const g = svg.querySelector('g');
            if (g) {
                g.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                g.style.transformOrigin = '0 0';
            }
        }

        // Reset zoom function
        (window as any).resetZoom = () => {
            scale = 1;
            translateX = 0;
            translateY = 0;
            updateTransform();
        };
    }
</script>
